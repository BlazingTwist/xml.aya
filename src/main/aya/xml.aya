require stack {stack}
require ".xpath" {xpath}

class xml
class xmlns .# same as xml, but with namespace support enabled. This affects how xpath can be evaluated
::xmlns xml extend;

.{? xmlns::loads {xml_str::str ignore_whitespace::num xmlns}
    Loads an xml document with namespace support.
    - xml_str : the xml document
    - ignore_whitespace : true = no tokens are constructed for trivial whitespace (pure whitespace between elements)
.}
def xmlns::loads {xml_str::str ignore_whitespace::num xmlns,
	xml_str ignore_whitespace 1 :(vtd.loads) xmlns!
}

.{? xmlns::loadf {xml_file::str ignore_whitespace::num xmlns}
    Loads an xml document with namespace support.
    - xml_file : the path of the xml document
    - ignore_whitespace : true = no tokens are constructed for trivial whitespace (pure whitespace between elements)
.}
def xmlns::loadf {xml_file::str ignore_whitespace::num xmlns,
	xml_file ignore_whitespace 1 :(vtd.loadf) xmlns!
}

def xmlns::__repr__ {self,
	"($(self.xml_id) xmlns!)"
}

.{? xmlns::xpath {ns_dict::dict xpath_str::str self}
    Compile an xpath expression for use with this xml document.
    - ns_dict::dict<str,str> : namespace URIs keyed by their prefix, e.g. :{"my/ns/uri":mnu} can then be used in an xpath like this: '//mnu:node'
.}
def xmlns::xpath {ns_dict::dict xpath_str::str self : xpath^,
	self.xml_id ns_dict xpath_str xpath.compile_ns
}

.{? xmlns::extract {ns_dict::[str]dict query_dict::[[str list]union]dict self_xml -> ::[list]dict}
    Same as xml.extract, but with an extra parameter:
	- ns_dict::dict<str,str> : namespace URIs keyed by their prefix, so that they can be used in xpath expressions.
.}
def xmlns::extract {ns_dict::[str]dict query_dict::[[str list]union]dict self_xml -> ::[list]dict,
	"query_dict" query_dict [{ns_dict\ self_xml.xpath}] self_xml._extract
}

.{? xml::loads {xml_str::str ignore_whitespace::num xml}
    - xml_str : the xml document
    - ignore_whitespace : true = no tokens are constructed for trivial whitespace (pure whitespace between elements)
.}
def xml::loads {xml_str::str ignore_whitespace::num xml,
    xml_str ignore_whitespace 0 :(vtd.loads) xml!
}

.{? xml::loadf {xml_file::str ignore_whitespace::num xml}
    - xml_file : the path of the xml document
    - ignore_whitespace : true = no tokens are constructed for trivial whitespace (pure whitespace between elements)
.}
def xml::loadf {xml_file::str ignore_whitespace::num xml,
    xml_file ignore_whitespace 0 :(vtd.loadf) xml!
}

def xml::__init__ {xml_id::num self,
    xml_id self.:xml_id;
}

def xml::__repr__ {self,
	"($(self.xml_id) xml!)"
}

.{? xml::to_str {self -> ::str}
    Write the loaded xml document to a string (including all modifications)
.}
def xml::to_str {self,
	self.xml_id :(vtd.dumps)
}

.{? xml::minify_xhtml {self -> ::str}
	Same as xml::minify, but with a special 'exclude_elements' preset for XHTML files: ["pre", "textarea", "script", "style"]
	Do note that this may still break documents that are making use of the CSS 'white-space' property.
.}
def xml::minify_xhtml {self,
	["pre", "textarea", "script", "style"] self.minify
}

.{? xml::xpath {xpath_str::str self -> ::xpath}
    Compile an xpath expression for use with this xml document.
.}
def xml::xpath {xpath_str::str self : xpath^,
	self.xml_id xpath_str xpath.compile
}

.{? xml::close {self}
    close this xml document to free up some memory.
.}
def xml::close {self,
	self.xml_id :(vtd.close)
}

.{? xml::extract {query_dict::[[str list]union]dict self_xml -> ::[list]dict}
    Returns output_dict::dict<str,list>
	- query_dict::dict<str,query>
	  typedef query = xpath::str                      : extracts a list of strings
	                | [xpath::str]                    : same as above
					| [xpath::str type::type]          : extract a list and convert to the type denoted by the symbol. May be one of [str char num]
					| [xpath::str nested::query_dict] : recursively extract each item using the 'nested' query_dict.
		- xpath is an XPath 1.0 expression
	
    The output_dict will receive the same keys as the query_dict.
	query_dict Examples:
		ex1. :{"//@attr":x} -> :{[..]:x}
		ex2. :{["//node/text()" ::num]:y} -> :{[..]:y}
		ex3. :{[ "//node" :{"text()":inner} ]:outer} -> :{ [.. :{ [..]:inner } ]:outer }
.}
def xml::extract {query_dict::[[str list]union]dict self_xml -> ::[list]dict,
	"query_dict" query_dict [{self_xml.xpath}] self_xml._extract
}

def xml::_extract {ctx_path query_dict xpath_factory self_xml,
	query_dict {key query : key_str check_type check_type_type,
		key :C :key_str;
		str :check_type;
		(query list :@) {query str :@!}& {
			{
				(query E 1 =) { query.[0]:query; }
				(query E 2 =) { query.[1]:check_type; query.[0]:query; }
				{ "illegal length ($(query E)) at $(ctx_path).$(key_str). Must be 1 or 2".D }
			}:?
		}?
		
		check_type dict :@ {
			query xpath_factory~~ {token_idx,
				"$(ctx_path).$(key_str)" check_type xpath_factory self_xml._extract
			}O
		}{ : xpath_result,
			.# extract string, then convert
			query xpath_factory~~ { self_xml._xpath_item_to_str}O :xpath_result;
			{
				(check_type str =) { xpath_result }
				(check_type char =) {
					xpath_result {item,
						item E 1 = {item.[0]}{"type assertion ::char failed at $(ctx_path).$(key_str) for value $(item)".D}.?
					}O
				}
				(check_type num =) {
					xpath_result {item,
						item .! :item;
						item num :@! {"type assertion ::num failed at $(ctx_path).$(key_str) for value $(item)".D}?
						item
					}O
				}
				{ "illegal type $(check_type) at $(ctx_path).$(key_str). Must be str, char or num".D }
			}:?
		}.?
	}O
}

def xml::_xpath_item_to_str {token_idx self : token,
	self.xml_id token_idx :(vtd.get_token) :token;
	{
		([::attr_name ::attr_ns] token.type H) { self.xml_id token_idx 1+ :(vtd.token_to_normalized_string) }
		(::starting_tag token.type =) { self.xml_id :& :(vtd.nav_get_element_fragment) :(vtd.fragment_to_raw_string) }
		{ self.xml_id token_idx :(vtd.token_to_normalized_string) }
	}:?
}

.{? xml::minify {exclude_elements::list self -> ::str}
    Remove all non-significant whitespace from the xml document.
    - exclude_elements::list<str> : list of element names whose content won't be modified.
    Returns the minified document as a string.
.}
def xml::minify {exclude_elements::list self : unclosed_tokens xml_declaration_open xml_tag_open emit_close_tags emit_fragment is_in_excluded_tag push_token stack^,
    0 :xml_declaration_open;
    0 :xml_tag_open;
    [] stack! :unclosed_tokens;
	0 :is_in_excluded_tag;
	{ token,
		token unclosed_tokens.push;
		is_in_excluded_tag ! {
			(exclude_elements E 0 >) { exclude_elements token.raw ': S B\; H } & {
				.# now entering an excluded tag
				1 :is_in_excluded_tag;
			}?
		}?
	} :push_token;
	
	{ : frag_off frag_len,
		.# we have exited the blocked token content -> close the starting-tag and insert the content-fragment.
		self.xml_id unclosed_tokens.peek.i :(vtd.nav_to_token)
		self.xml_id :(vtd.nav_get_content_fragment) :frag_len; :frag_off;
		frag_len 0 < {
			.# tag without content
			"/>"
			unclosed_tokens.pop;
		}{
			.# tag with content
			">"
			self.xml_id frag_off frag_len :(vtd.fragment_to_raw_string)
		}.?
		0 :xml_tag_open;
		0 :is_in_excluded_tag;
	}:emit_fragment;

	{depth::num : condition,
		xml_tag_open {
			0 :xml_tag_open;
			"/>"
			unclosed_tokens.pop;
		}?
		depth 0 .< :depth;
		while {depth unclosed_tokens E <} {
			"</" unclosed_tokens.pop.raw ">"
		}
	}:emit_close_tags;

    self.xml_id :(vtd.get_token_count) .R {i,
		(self.xml_id i :(vtd.get_token)) :{
			i :i;
			self.xml_id i :(vtd.token_to_raw_string) :raw;
		} .+
    } O {token,
        .# skip trivial whitespace
        (token.type ::character_data =) {token.raw .trim E 0 =} & !
    } I {token,
        {
            (token.type ::dec_attr_name =) {
                xml_declaration_open ! {
                    "<?xml"
                    1 :xml_declaration_open;
                }?
            } (token.type ::dec_attr_val =) {
                xml_declaration_open ! {
                    "<?xml "
                    1 :xml_declaration_open;
                }?
            } {
                xml_declaration_open {
                    "?>"
                    0 :xml_declaration_open;
                }?
            }
        }:?
		
		is_in_excluded_tag {
			[ ::starting_tag ::character_data ::comment ::pi_name ::cdata_val ] token.type H {
				0 :xml_tag_open; .# tag will eventually be closed by emit_fragment, but already mark as closed to stop tracking nested attributes
				token.depth unclosed_tokens E < { : frag_off frag_len,
					emit_fragment
				}?
			}?
			
			{
				(xml_tag_open !) {} .# skip nested attributes
				([::attr_ns ::attr_name] token.type H) {
					" " token.raw+
				} (::attr_val token.type =) {
					"=\"" token.raw "\""++
				}
			}:?
		}?
		
		is_in_excluded_tag ! {
			[ ::starting_tag ::character_data ::comment ::pi_name ::cdata_val ] token.type H {
				xml_tag_open {
					(token.depth unclosed_tokens E <) {unclosed_tokens E 0 >} & {
						.# currently open tag has no content
						"/>"
						unclosed_tokens.pop;
					}{
						">"
					}.?
					0 :xml_tag_open;
				}?
				token.depth emit_close_tags
			}?

			{
				(token.type ::starting_tag =) {
					"<" token.raw +
					token push_token
					1 :xml_tag_open;
				} ([::dec_attr_name ::attr_ns ::attr_name] token.type H) {
					" " token.raw+
				} ([::dec_attr_val ::attr_val] token.type H) {
					"=\"" token.raw "\""++
				} (token.type ::character_data =) {
					token.raw.trim
				} (token.type ::comment =) {
					"<!--" token.raw "-->"++
				} (token.type ::pi_name =) {
					"<?" token.raw+
				} (token.type ::pi_val =) {
					token.raw E 0 = {""}{" " token.raw+}.? "?>"+
				} (token.type ::cdata_val =) {
					"<![CDATA[" token.raw "]]>"++
				} (token.type ::dtd_val =) {
					"<!DOCTYPE" token.raw ">"++
				}
			}:?
		}?
    } O "" % .# partial result on stack...

	is_in_excluded_tag {
		[emit_fragment] "" % +
	}?

    .# close any unclosed tags
    [
        0 emit_close_tags
    ] "" % +
}

.{? xml::prettify_xhtml {self -> ::str}
	Same as xml::prettify, but with a special 'exclude_elements' preset for XHTML files: ["pre", "textarea", "script", "style"]
	Do note that this may still break documents that are making use of the CSS 'white-space' property.
.}
def xml::prettify_xhtml {self,
	:{
		1:reindent_multiline_text;
		["pre", "textarea", "script", "style"]:exclude_elements;
	} self.prettify
}

.{? xml::prettify {options::dict self -> ::str}
	Inserts non-significant whitespace into the xml document for printing.
	- options::dict {
		reindent_multiline_text::bool : if true lines of multiline text will be trimmed and indented individually | otherwise (if false) text blocks are kept as is.
		exclude_elements::list        : list of element names whose content won't be modified.
		extra_indentation::str        : additional indentation prefixed to every line, with respect to the other options.
	}
	Returns the prettified document as a string.
.}
def xml::prettify {options::dict self
			: reindent_multiline_text exclude_elements extra_indentation
			  newline
			  unclosed_tokens xml_declaration_open xml_tag_open tag_has_multiline_content
			  emit any_emitted is_in_excluded_tag push_token stack^,
	0:reindent_multiline_text;
	[]:exclude_elements;
	"":extra_indentation;
	options~
	"\n" extra_indentation + :newline;

	0 :xml_declaration_open;
    0 :xml_tag_open;
	0 :tag_has_multiline_content;
	0 :any_emitted;
    [] stack! :unclosed_tokens;
	0 :is_in_excluded_tag;
	
	{text,
		1 :any_emitted;
		text
	}:emit;
	
	{ token,
		token unclosed_tokens.push;
		is_in_excluded_tag ! {
			(exclude_elements E 0 >) { exclude_elements token.raw ': S B\; H } & {
				.# now entering an excluded tag
				1 :is_in_excluded_tag;
			}?
		}?
	}:push_token;
	
	{ : frag_off frag_len,
		.# we have exited the blocked token content -> close the starting-tag and insert the content-fragment.
		self.xml_id unclosed_tokens.peek.i :(vtd.nav_to_token)
		self.xml_id :(vtd.nav_get_content_fragment) :frag_len; :frag_off;
		frag_len 0 < {
			.# tag without content
			"/>" emit
			unclosed_tokens.pop;
		}{
			.# tag with content
			">" self.xml_id frag_off frag_len :(vtd.fragment_to_raw_string) +emit
		}.?
		0 :xml_tag_open;
		0 :is_in_excluded_tag;
	}:emit_fragment;
	
	self.xml_id :(vtd.get_token_count) .R {i,
		(self.xml_id i :(vtd.get_token)) :{
			i :i;
			self.xml_id i :(vtd.token_to_raw_string) :raw;
		} .+
    } O {token,
        .# skip trivial whitespace
        (token.type ::character_data =) {token.raw .trim E 0 =} & !
    } I {token : is_multiline_text,
        {
            (token.type ::dec_attr_name =) {
                xml_declaration_open ! {
                    "<?xml" emit
                    1 :xml_declaration_open;
                }?
            } (token.type ::dec_attr_val =) {
                xml_declaration_open ! {
                    "<?xml " emit
                    1 :xml_declaration_open;
                }?
            } {
                xml_declaration_open {
                    "?>" emit
                    0 :xml_declaration_open;
                }?
            }
        }:?
		
		is_in_excluded_tag {
			[ ::starting_tag ::character_data ::comment ::pi_name ::cdata_val ] token.type H {
				0 :xml_tag_open; .# tag will eventually be closed by emit_fragment, but already mark as closed to stop tracking nested attributes
				token.depth unclosed_tokens E < { : frag_off frag_len,
					emit_fragment
				}?
			}?

			{
				(xml_tag_open !) {} .# skip nested attributes
				([::attr_ns ::attr_name] token.type H) {
					" " token.raw+emit
				} (::attr_val token.type =) {
					"=\"" token.raw "\""++emit
				}
			}:?
		}?
		
		is_in_excluded_tag ! {
			[ ::starting_tag ::character_data ::comment ::pi_name ::cdata_val ] token.type H {
				(token.type ::character_data = !) {reindent_multiline_text {token.raw '\n' H} &} | :is_multiline_text;
				
				[{is_multiline_text} {tag_has_multiline_content !} {token.depth unclosed_tokens E :>}] {&} % {
					1 :tag_has_multiline_content;
				}?
				xml_tag_open {
					">" emit
					0 :xml_tag_open;
				}?

				while {(token.depth unclosed_tokens E <) {unclosed_tokens E 0 >} &} { : pop_token,
					unclosed_tokens.pop :pop_token;
					tag_has_multiline_content {
						newline '\t' pop_token.depth 0 .< L +emit
					}{
						1 :tag_has_multiline_content;
					}.?
					"</" pop_token.raw ">" ++emit
				}
				any_emitted tag_has_multiline_content & {
					newline '\t' token.depth 0 .< L +emit
				}?
			}?

			{
				(token.type ::starting_tag =) {
					"<" token.raw +emit
					1 :xml_tag_open;
					0 :tag_has_multiline_content;
					token push_token
				} ([::dec_attr_name ::attr_ns ::attr_name] token.type H) {
					" " token.raw +emit
				} ([::dec_attr_val ::attr_val] token.type H) {
					"=\"" token.raw "\"" ++emit
				} (token.type ::character_data =) {
					token.raw.trim
					reindent_multiline_text {
						:& '\n' H {
							"\\s*\\r?\\n\\s*" (newline '\t' token.depth L +) .&
						}?
					}?
					emit
				} (token.type ::comment =) {
					"<!--" token.raw "-->" ++emit
				} (token.type ::pi_name =) {
					"<?" token.raw +emit
				} (token.type ::pi_val =) {
					token.raw E 0 ={""}{" " token.raw+}.? "?>"+emit
				} (token.type ::cdata_val =) {
					"<![CDATA[" token.raw "]]>" ++emit
				} (token.type ::dtd_val =) {
					any_emitted {newline}{""}.?
					"<!DOCTYPE" token.raw ">" +++emit
				}
			}:?
		}?
    } O "" % .# partial result on stack...
	extra_indentation\+
	
	is_in_excluded_tag {
		[emit_fragment] "" % +
	}{
		xml_tag_open {">"+}?
	}.?
	
	.# close any unclosed tags
	[
		while {unclosed_tokens E 0 >} { : pop_token,
			unclosed_tokens.pop :pop_token;
			tag_has_multiline_content {
				newline '\t' pop_token.depth 0 .< L
			}{
				1 :tag_has_multiline_content;
			}.?
			"</" pop_token.raw ">"
		}
	] "" % +
}